const mustache = require('mustache');

const NO_NUMBERS_REGEXP = /[^\d.]/;
const REGEXP = new RegExp(
    /\{\{\s*#\s*(([^\s}]+)\s+[^}]+)\}\}([\s\S]+?)\{\{\s*\/\s*\2\s*\}\}/.source + '|' +
    /\{\{\s*([><])\s*([^\s}]+)\s*\}\}([\s\S]+?)\{\{\s*\/\s*\5\s*\}\}/.source + '|' +
    /\{\{\s*<\s*([^}]+)\}\}/.source + '|' +
    /\{\{\s*([^\s}]+\s+[^}]+)\}\}/.source,
    'g'
);

class Moustache {

    helper(type, placeholder) {
        this.partials = this.partials || {};
        var partials = this.partials;

        return function (text, render) {
            if ('extend' === type) {
                render(text); /* Just set the partials */
                return render('{{>' + placeholder + '}}');
            } else if ('partial' === type) {
                partials[placeholder] = text;
                return;
            } else if ('section' === type) {
                return render(partials[placeholder]);
            }

            text = text.split('\n');
            let statement = text.shift().split(' ');
            let action = statement.shift();
            text = text.join('\n');

            if ('function' !== typeof this[action]) {
                return this[action] || '';
            }

            let deepness = 0;
            let delimiter;
            let parameters = [];
            let properties = {};
            let property;
            let string;
            let subStatement;

            statement.forEach((token) => {
                if (subStatement) {
                    subStatement += ' ' + token;
                    if ('(' === token[0]) {
                        deepness++;
                    }
                    if (')' === token[token.length - 1]) {
                        if (deepness) {
                            deepness--;
                            return;
                        }
                        let text = subStatement.substring(1, subStatement.length - 1);
                        subStatement = this.moustache.render.bind(this)().bind(this)(text, render);
                    } else {
                        return;
                    }
                } else if (string) {
                    string += ' ' + token;
                    if (delimiter === token[token.length - 1]) {
                        string = string.substring(1, string.length - 1);
                        delimiter = null;
                    } else {
                        return;
                    }
                } else {
                    if (-1 !== token.indexOf('=')) {
                        token = token.split('=');
                        property = token.shift().trim();
                        token = token.join('=').trim();
                    }

                    if (-1 !== '\'"`'.indexOf(token[0])) {
                        if (token[0] === token[token.length - 1]) { /* Delimited string */
                            string = token.substring(1, token.length - 1);
                        } else {
                            string = token;
                            delimiter = string[0];
                            return;
                        }
                    } else if ('(' === token[0]) {
                        if (')' === token[token.length - 1]) { /* Delimited subStatement */
                            subStatement = this[token.substring(1, token.length - 1).trim()];
                        } else {
                            subStatement = token;
                            return;
                        }
                    }
                }

                let result = subStatement || string;

                if (!result) {
                    if (!NO_NUMBERS_REGEXP.test(token)) {
                        result = token;
                    } else if (0 < token.indexOf('.')) {
                        token = token.split('.');
                        result = this;
                        while (token.length) {
                            result = (result || {})[token.shift()];
                        }
                    } else {
                        result = this[token];
                    }
                }

                subStatement = null;
                string = null;

                if (property) {
                    properties[property] = result;
                    property = null;
                } else {
                    parameters.push(result);
                }
            }, []);

            parameters.push(properties);
            let response = this[action].apply(this, parameters);

            if ('function' === typeof response) {
                return response.bind(this)(text, render);
            }

            return response;
        }
    }

    compile(moustache) {
        var lastIndex = REGEXP.lastIndex;
        var match;
        var mustache = '';
        var offset = 0;

        REGEXP.lastIndex = 0;

        while (match = REGEXP.exec(moustache)) {
            if (match[8] && -1 !== '#^/!&{='.indexOf(match[8][0])) {
                continue;
            }

            mustache += moustache.substring(offset, match.index);

            if (undefined !== match[1]) {
                mustache += '{{#moustache}}' + match[1].trim() + '\n' + this.compile(match[3]) +'{{/moustache}}';
            } else if ('>' === match[4]) {
                mustache += '{{#moustache}}moustache "extend" "' + match[5].trim() + '"\n' +
                    this.compile(match[6]) + '{{/moustache}}';
            } else if ('<' === match[4]) {
                mustache += '{{#moustache}}moustache "partial" "' + match[5].trim() + '"\n' +
                    this.compile(match[6]) + '{{/moustache}}';
            } else if (undefined !== match[7]) {
                mustache += '{{#moustache}}moustache "section" "' + match[7].trim() + '"{{/moustache}}';
            } else {
                mustache += '{{#moustache}}' + match[8].trim() + '{{/moustache}}';
            }

            offset = match.index + match[0].length;
        }

        REGEXP.lastIndex = lastIndex;

        if (offset < moustache.length) {
            mustache += moustache.substring(offset);
        }

        return mustache;
    }

    parse(template, tags) {
        return mustache.parse(this.compile(template), tags);
    }

    render(template, view, partials) {
        if (view) {
            let moustache = new Moustache;
            view.moustache = moustache.helper;
        }

        if (partials) {
            for (var partial in partials) {
                if (partials.hasOwnProperty(partial)) {
                    partials[partial] = this.compile(partials[partial]);
                }
            }
        }

        return mustache.render(this.compile(template), view, partials);
    }

}

module.exports = new Moustache;
